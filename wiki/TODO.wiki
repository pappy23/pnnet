== Че надо делать в первую очередь? ==
  * Написать парсер PPM/PGM/PBM, убрать зависимости от boost::gil/libjpeg

  * Несимметричные или параллельные линки. Они никак не отлавливаются.
{{{
Net::addConnection() нормально работает, но пользователю доступны ф-ии нейрона напрямую,
т.е. он может соединить их вообще как душе угодно. Это не есть хорошо.
}}}

  * Проверить качество алгоритма обучения, его соответствие теории, особенно с общими линками.

  * Модель сверточной сети. Неплохо бы ее как-то формализовать, выделить подпрограммы и т.п. Потому что то что есть - выглядит ужасно.

  * Автоматическое тестирование.
Можно заюзать boost unit test library. Довольно прикольная штука.
Читать CTest для юнит-тестирования

  * Починить сериализацию так, что бы она не хавала столько стека. Пока что решение - юзать ulimit -s
{{{
Код сериализации сейчас очень красивый. Все замечательно, кроме того,
что он сильно рекуррентный. Нужно придумать красивое решение проблемы.
Пока что предлагаю, пока красивого решения нет, не пороть горячку и ничего не трогать.
Будем довольствоваться увеличением стека.
}}}

  * Doxygen

  * Описание в отдельном доке(статьи)
{{{
Возможные проблемы и варианты их решения будут или сдесь, или в коде с пометкой TODO.
Сложно держать внешнюю документацию в актуальном состоянии.
}}}

  * ~~После рефакторинга ядра нужно проверить все. Написать Unit-тесты и пр. Все ли деструкторы вызываются, нет ли зависших нейронов/линков, нет ли неоднозначностей с рекуррентными топологиями?~~
{{{
Проверил. Все деструкторы вовремя вызываются.
В принципе то что касается Core, полностью покрыто тестом TestNet. 
Все остальное вроде как тоже неплохо покрывается с помощью других тестов. 
Не думаю что целесообразно писать унылые юнит-тесты, что бы тестить класс с двумя методами.
Прогнал тестовые программы через valgrind - никаких проблем. 
Обнаружены только проблемы с производительностью. Но это уже совсем другая история.
Рекуррентные топологии поддерживаются в полном объеме.
Ограничения топологии:
 - можно напутать с latency и тогда топология может неправильно строить кеш. В таких нештатных ситуациях алгоритм не тестировался.
 - если удалить нейрон, то указатель на него остается в кеше, так что реально нейрон удаляется только при перестройке кеша.
Это не проблема, просто надо об этом помнить
 - если удалить нейроны так, что кусок топологии останется отрезан от входных нейронов,
то этот кусок останется висеть в памяти до завершения программы, потому как оставшиеся
нейроны будут продолжать ссылаться друг на друга. 
Не думаю что это такая уж большая проблема и ее нужно кидаться фиксить. 
Просто надо об этом помнить. 
weak_ptr внутри Link не предлагать.
}}}

 * ~~oprofile, valgrind - отловить тормоза и пр.~~
{{{
valgrind опробован. Лед тронулся. Будем юзать. Когда понадобиться что-то оптимизировать.
}}}

  * ~~Ограничения волнового алгоритма. См. каменты в коде~~
{{{
Поменял алгоритм. Проверил на Хопфилд-подобной архитектуре(см. TestNet.cpp).
С виду - никаких проблем. Поживем, увидим, как оно.
}}}

  * ~~Проблемы с addConnection/delConnection. См. TODO коде~~
{{{
Да, выглядит не очень эстетично, но работает. Больше волнует проблема с возможными параллельными или несимметричными линками.
}}}

  * ~~Всякая всячина, помеченная в коде как TODO, FIXME~~
{{{
Лед тронулся. Будем юзать. Периодически буду делать `grep TODO *`
}}}